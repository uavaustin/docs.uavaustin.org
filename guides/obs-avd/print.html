<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Intro to Obstacle Avoidance</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="index.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="background/index.html"><strong aria-hidden="true">2.</strong> Background</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="background/basic-graph-theory.html"><strong aria-hidden="true">2.1.</strong> Basic Graph Theory</a></li><li class="chapter-item expanded "><a href="background/greedy-algorithm.html"><strong aria-hidden="true">2.2.</strong> Greedy Algorithm</a></li><li class="chapter-item expanded "><a href="background/dijkstras-algorithm.html"><strong aria-hidden="true">2.3.</strong> Dijkstra's Algorithm</a></li><li class="chapter-item expanded "><a href="background/a-star-algorithm.html"><strong aria-hidden="true">2.4.</strong> A* Algorithm</a></li></ol></li><li class="chapter-item expanded "><a href="pathfinder-library/index.html"><strong aria-hidden="true">3.</strong> Pathfinder Library</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="pathfinder-library/library-overview.html"><strong aria-hidden="true">3.1.</strong> Library Overview</a></li><li class="chapter-item expanded "><a href="pathfinder-library/map-presentation.html"><strong aria-hidden="true">3.2.</strong> Map Representation</a></li><li class="chapter-item expanded "><a href="pathfinder-library/implementation-details.html"><strong aria-hidden="true">3.3.</strong> Implementation Details</a></li><li class="chapter-item expanded "><a href="pathfinder-library/future-goals.html"><strong aria-hidden="true">3.4.</strong> Future Goals</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Intro to Obstacle Avoidance</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#introduction" id="introduction">Introduction</a></h1>
<p>This guide gives an introduction to the pathfinder library, a Rust library built for obstacle avoidance.  This guide will walk through the theory behind the algorithms and their implementation details.</p>
<ul>
<li>
<p><a href="background/index.html">Background</a></p>
<ul>
<li><a href="background/basic-graph-theory.html">Basic Graph Theory</a></li>
<li><a href="background/greedy-algorithm.html">Greedy Algorithm</a></li>
<li><a href="background/dijkstras-algorithm.html">Dijkstra's Algorithm</a></li>
<li><a href="background/a-star-algorithm.html">A* Algorithm</a></li>
</ul>
</li>
<li>
<p><a href="pathfinder-library/index.html">Pathfinder Library</a></p>
<ul>
<li><a href="pathfinder-library/library-overview.html">Library Overview</a></li>
<li><a href="pathfinder-library/map-presentation.html">Map Representation</a></li>
<li><a href="pathfinder-library/implementation-details.html">Implementation Details</a></li>
<li><a href="pathfinder-library/future-goals.html">Future Goals</a></li>
</ul>
</li>
</ul>
<h1><a class="header" href="#background" id="background">Background</a></h1>
<p>This section covers the basic definitions and algorithms used in graph theory.</p>
<ul>
<li><a href="background/basic-graph-theory.html">Basic Graph Theory</a></li>
<li><a href="background/greedy-algorithm.html">Greedy Algorithm</a></li>
<li><a href="background/dijkstras-algorithm.html">Dijkstra's Algorithm</a></li>
<li><a href="background/a-star-algorithm.html">A* Algorithm</a></li>
</ul>
<h1><a class="header" href="#references" id="references">References</a></h1>
<p>extensive write up on various pathfinding algorithms: https://www.redblobgames.com/</p>
<p>visualization: https://qiao.github.io/PathFinding.js/visual/</p>
<h1><a class="header" href="#basic-graph-theory" id="basic-graph-theory">Basic graph theory</a></h1>
<p>This section covers the common definitions and ideas used in graph theory</p>
<h2><a class="header" href="#definitions" id="definitions">Definitions</a></h2>
<p><strong>Graph</strong><br />
an ordered pair (V, E) where V is the set of nodes and E is the set of edges</p>
<p><strong>Undirected graph</strong><br />
a graph where the edge between two nodes are the same regardless of the direction.  I.E edge (x, y) is equivalent to (y, x)</p>
<p><strong>Directed graph</strong><br />
a graph where the the edge between two nodes are distinguish by their orientation</p>
<p><strong>Weighted graph</strong><br />
a graph where the edges have numerical weights indicating preference</p>
<p><strong>Connected graph</strong><br />
a connected graph is a graph where any node is reachable from every other node</p>
<p><strong>Cycle</strong><br />
a cycle in a graph means there exists a path that leads back to the starting point.  In undirected graph, a cycle must contains at least 3 nodes</p>
<p><strong>Acyclic graph</strong><br />
an acyclic graph contains no cycles</p>
<p><strong>Order</strong><br />
the order of a graph is denoted by |V| and represents the number of nodes</p>
<p><strong>Size</strong><br />
the size of a graph is denoted by |E| and represents the number of edges</p>
<p><strong>Tree</strong><br />
a tree is an acyclic connected undirected graph</p>
<p><strong>Rooted tree</strong>
a tree where a node is indicated as the root node and all other nodes are define in relation to the root</p>
<p><strong>Leaf node</strong>
a node in a rooted tree with no children</p>
<h2><a class="header" href="#graph-representation" id="graph-representation">Graph representation</a></h2>
<p>A graph needs to be somehow represented in memory.  The main representations are adjacency list and adjacency matrix.</p>
<p><strong>Adjacency list</strong><br />
Each node keeps track of their connected neighbor and their weights.  Good for sparse graphs.</p>
<p><strong>Adjacency matrix</strong>
A matrix keeps track of what whether an edge exists between two nodes.  Good for dense graphs.  Additionally, looking up if two nodes are connected takes constant time at the cost of taking up more space.</p>
<h2><a class="header" href="#heuristics" id="heuristics">Heuristics</a></h2>
<p>To calculating the shortest path, we need to accurately estimate the distance between two nodes.  The common heustrics used for this purpose are Manhattan distance, Euclidean distance, and Diagonal distance.</p>
<p><img src="background/../img/graph.png" alt="" title="Sample graph" /></p>
<p><strong>Manhattan distance</strong> - the sum of horizontal and vertical offset between two points on a grid</p>
<p>\( D = dx + dy \)</p>
<p>Ex: \( dx + dy = 6 + 4 = 10 \)</p>
<p><strong>Euclidean distance</strong> - the actual distance between two points on a grid using Pythagorean Theorem</p>
<p>\( D = \sqrt{dx^2 + dy^2} \)</p>
<p>Ex: \( \sqrt{dx^2 + dy^2} = \sqrt{6^2 + 4^2} \approx 7.2 \)</p>
<p><strong>Diagonal distance</strong> - same as manhattan distance, but allows diagonal movements</p>
<p>\( D = (dx + dy) + (C - 2) * min(dx, dy) \), where C is cost of moving diagonally</p>
<p>if \(C = 1\), this is known as <strong>Chebyshev distance</strong></p>
<p>Ex: \( (dx + dy) + (C - 2) * min(dx, dy) = (4 + 6) + (1 - 2) * min(4, 6) = 6\)</p>
<p>if \(C = \sqrt{2}\), this is known as <strong>Octile distance</strong></p>
<p>Ex: \( (dx + dy) + (C - 2) * min(dx, dy) = (4 + 6) + (\sqrt{2} - 2) * min(4, 6) \approx 7.7 \)</p>
<h1><a class="header" href="#greedy-algorithm" id="greedy-algorithm">Greedy Algorithm</a></h1>
<p>Stems from depth first search.  Depth first search looks at a child of a node and follow it until it reaches the a leaf node, then follows another neighbor until all neighbors have been visited.  The greedy algorithm looks at all connected node and chooses the one closest to the target node based on a heuristic and navigate down that node.</p>
<h1><a class="header" href="#pseudocode" id="pseudocode">Pseudocode</a></h1>
<pre><code class="language-text">unmark all nodes
let S be a stack
S.push(start)

while S is not empty
  current_node = S.pop()
  if current_node == end
    return path
  end if
  if current_node is not marked:
    mark current_node as visited
    for all neighbor n of current_node
      n.parent = current_node
      n.cost = heuristic(n, end)
    end for
    order current_node.neighbors by cost and push to S
  end if
end while
</code></pre>
<h1><a class="header" href="#problem" id="problem">Problem</a></h1>
<p>Fast, but can get stuck on obstacles and therefore not guaranteed to find shortest path.</p>
<p><img src="background/../img/greedy-problem.png" alt="" title="Greedy problem" /></p>
<h1><a class="header" href="#breadth-first-search" id="breadth-first-search">Breadth First search</a></h1>
<p>Breadth first search starts at a node and evaluate all of its immediate neighbors before evaluating their children.  In other words, it starts to a node and evaluate all children one node away from it, then evaluate all children two nodes away from it, and so on.</p>
<h1><a class="header" href="#dijkstras-algorithm" id="dijkstras-algorithm">Dijkstra's Algorithm</a></h1>
<p>Dijkstra build on top of breadth first search but accounts for movement cost to prioritize path with lower cost but redirecting parent of a node if there is a shorter alternate path to it.  For example, node 1 is originally parent of node 2 (i.e node 2 came from node 1). If,  while evaluating node 3 neighboring node 2, the algorithm finds the cost of moving from node 3 to node 2 is lower than that of its current cost, node 2's parent would be changed to node 3 and its cost updated accordingly.</p>
<h1><a class="header" href="#pseudocode-1" id="pseudocode-1">Pseudocode</a></h1>
<pre><code class="language-text">for all node n
  n.cost = INFINITY
end for
let Q be a queue
Q.push(start)

while Q is not empty
  current_node = Q.pop()
  if current_node == end
    return path
  end if

  for neighbor n of current_node
    if cost(current_node, n) &lt; n.cost
      n.parent = current_node
      n.cost = cost(current_node, n)
    end if
    Q.push(neighbor)
  end for
end while
</code></pre>
<h1><a class="header" href="#problem-1" id="problem-1">Problem</a></h1>
<p>guaranteed to find the shortest path, but takes much longer</p>
<p><img src="background/../img/dijkstra-problem.png" alt="" title="dijkstra problem" /></p>
<h1><a class="header" href="#a-algorithm" id="a-algorithm">A* Algorithm</a></h1>
<p>Combine greedy and dijkstra's algorithm to gurantee both speed and correctness.  Works by calculating cost of a node by combining movement cost and heuristic estimating the distance to target.</p>
<p>\( f(n) = g(n) + h(n) \)</p>
<p>where g(n) is the cost of the shorest path from start to n, and h(n) is a heuristic function estimating the cost of the direct path to the target.</p>
<h1><a class="header" href="#pseudocode-2" id="pseudocode-2">Pseudocode</a></h1>
<pre><code class="language-text">unmark all nodes
for all node n
  n.cost = INFINITY
end for
let S be a set
S.push(start)

while S is not empty
  current_node = node in S with lowest cost
  if current_node == end
    return path
  end if

  mark current_node as visited
  for neighbor n of current_node
    if neighbor is marked
      continue
    end if
    cost = cost(current_node, n) + heuristic(n, end)
    if cost &lt; n.cost
      n.parent = current_node
      n.cost = cost
    end if
    S.push(neighbor)
  end for
end while
</code></pre>
<p><img src="background/../img/a-star-result.png" alt="" title="A* result" /></p>
<h1><a class="header" href="#pathfinder-library" id="pathfinder-library">Pathfinder Library</a></h1>
<p>The section covers the overall structure of the pathfinder library and the detailed implementation of the algorithm.</p>
<ul>
<li><a href="pathfinder-library/library-overview.html">Library Overview</a></li>
<li><a href="pathfinder-library/map-presentation.html">Map Representation</a></li>
<li><a href="pathfinder-library/implementation-details.html">Implementation Details</a></li>
<li><a href="pathfinder-library/future-goals.html">Future Goals</a></li>
</ul>
<h1><a class="header" href="#exposed-api" id="exposed-api">Exposed API</a></h1>
<p>The library is structured as a Pathfinder object which must be initialized before it can process path finding requests.  For initialization, it requires the following parameters:</p>
<ul>
<li><code>grid_size</code>: denotes how large a node in the grid is in meters</li>
<li><code>flyzones</code>: a 2D vector of Point object representing the flyzones due to the possibility of multiple flyzones</li>
<li><code>obstacles</code>: a vector of Obstacle objects</li>
</ul>
<p>The following parameters are exposed through getter/setter methods</p>
<ul>
<li><code>grid_size</code>: denotes how large a node in the grid is in meters</li>
<li><code>buffer</code>: a buffer radius that's added to obstacles radius in meters</li>
<li><code>max_process_time</code>: amount of time to adjust the path before returning in seconds</li>
<li><code>fly_zones</code>: the list of flyzones boundary</li>
<li><code>obstacles</code>: the list of obstacles</li>
</ul>
<p>The main functionality of the pathfinder library is the get_adjust_path method, which takes the plane position and a list of waypoints and returns a modified list of waypoints that circumvents obstacles.</p>
<h1><a class="header" href="#library-structure" id="library-structure">Library Structure</a></h1>
<p>The code base is divided into several files for organizational purposes.  They are:</p>
<ul>
<li><code>lib.rs</code> - contains the definition for the Pathfinder struct and implementation of the obstacle avoidance algorithms</li>
<li><code>node.rs</code> - defines the node struct which represent a node in the grid and contains methods to convert between node and point representing physical coordinates.</li>
<li><code>obj.rs</code> - defines other data structures such as Plane, Obstacles, Point, and Waypoint for API interface.</li>
<li><code>util.rs</code> - contains utility functions</li>
</ul>
<h1><a class="header" href="#map-representation" id="map-representation">Map Representation</a></h1>
<p>Real world locations are in latitude and longitude, but A* has to operate on a graph which requires converting the map to a grid.</p>
<p>Since the plane can never be outside of the flyzone, we leverage this fact to find the lowest latitude and longitude of the flyzone and set that as the origin of the grid.  Henceforth, all points can be converted to a node by calculating the horizontal distance and vertical distance using the haversine formula, a formula that determines the great-circle distance between two points on a sphere.  Then, dividing the distance by the preset grid size will grant us the coordinate of the corresponding node.</p>
<p><img src="pathfinder-library/../img/raw-map.png" alt="" title="raw map" /></p>
<p>To keep track of obstacles, we keep a hashmap of nodes which can be looked up in constant time.  Since all obstacles are circular, we calculate the perimeter nodes and add them to the obstacle list.  Flyzones are treated as obstacles as well and can be represented by generating lines between points and adding nodes along said lines to the obstacle list.</p>
<p><img src="pathfinder-library/../img/sample-map.png" alt="" title="sample map" /></p>
<h1><a class="header" href="#data-structures" id="data-structures">Data structures</a></h1>
<h2><a class="header" href="#hash-table" id="hash-table">Hash table</a></h2>
<p>Hash table operates on the principle of a lookup table. Given an array of integers, you can make the integer themselves the index of the array and skip there to check if it exists.  For instance, given an array of unsigned integers [1, 3, 5], you can make an array of booleans with contents [false, true, false, true, false, true].  Then, checking if 1 is in the array is as simple as checking if array[1] is true.  With this, element look up can be done in constant time regardless of the size of the array.</p>
<p>However, if one was to insert 7 into the array, he would encounter an index out of bounds exception.  This can be remedied by a hash function, which essentially converts a number down to the length of the array.  Additionally, instead of having booleans as values, linked lists would be used instead. An extremely simple hash function in this case could be <code>n mod 6</code>, which would group 7 under array[1].  It can then be looked up in the linked list.</p>
<h2><a class="header" href="#binary-heap" id="binary-heap">Binary heap</a></h2>
<p>A binary heap is a special case of a complete binary tree.  There's many types of binary heap, but the most common ones are min heap and max heap.  In a min heap, the children of a node is always greater than the value of the node.  A max heap is similar except the children is always less than the its parent.  Through this structure, the root of the heap is always the minimum (maximum) of the tree and can be retrieved quickly.</p>
<p><img src="pathfinder-library/../img/min-heap.png" alt="" title="min heap" /></p>
<h1><a class="header" href="#implementation-details" id="implementation-details">Implementation Details</a></h1>
<p>All obstacles are stored in a hashset such that a node can be looked up in constant time.  Through this, while navigating through the grid, pathfinder can simply check if a node is in the obstalce list to see if the node is accessible.  All nodes that have been evaluated are stored in the <code>close_list</code> hashset while all nodes that are yet to be evaluated but have been discovered are stored in the <code>open_list</code> hashset.  Nodes in <code>open_list</code> are also stored in a binary heap named <code>open_heap</code> to retrieve the node with the minimum cost in \(O(log n)\) time.</p>
<p>To generate waypoints from the path found, we take advantage of the fact that the shortest path will always border an obstacle, and mark nodes bordering such an obstacle, or critical nodes.  Then, the critical nodes can be aggregated to generate the waypoints.</p>
<h1><a class="header" href="#influencing-the-path" id="influencing-the-path">Influencing the path</a></h1>
<p>The generated path can be influenced with additional modifiers in the cost function.  For instance, by taking the cross product of the vector from start node to end node with the heading vector between the current node and its neighbor, we can add the result to the cost heuristic.  Since the cross product between two parallel vectors is zero, this would cause the algorithm to favor direct paths over round about ones.</p>
<h1><a class="header" href="#future-goals" id="future-goals">Future Goals</a></h1>
<ul>
<li>
<p>Modularity - Currently, alternate algorithms cannot be chosen easily.  Therefore, there is plan for restructuring pathfinder to be more modular such that different algorithms can be chosen at run time.</p>
</li>
<li>
<p>Refinement - Furthermore, the current algorithm can continued to be refined to further optimize the generated path.  For instance, the algorithm does not account for the current heading of the plane, so a more roundabout path would be indistinguishable from an equally long but more direct path.</p>
</li>
<li>
<p>New approach - Moreover, with the insight that the shortest path always border on obstacles and the fact that all obstacles are circular, we can take advantage of this and make each obstacle a node in the graph, and generate weighted edges between them based on line of sight and distance.  This approach would completely eliminate the need to convert to a grid-based graph.</p>
</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        
        <!-- Google Analytics Tag -->
        <script type="text/javascript">
            var localAddrs = ["localhost", "127.0.0.1", ""];

            // make sure we don't activate google analytics if the developer is
            // inspecting the book locally...
            if (localAddrs.indexOf(document.location.hostname) === -1) {
                (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
                (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
                m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
                })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

                ga('create', 'UA-105339892-2', 'auto');
                ga('send', 'pageview');
            }
        </script>
        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
        
        

    </body>
</html>
